Bridgeパターン

bridgeというのは「橋」という意味で、
川のあちら側とこちら側という2つの場所を結びつける枠割を果たしているように、
Bridgeパターンも2つの場所を結びつける役割を果たす
Bridgeパターンが橋渡しをしている2つの場所は、
「機能のクラス階層」と「実装のクラス階層」になる。

クラス階層の2つの役割
・新しい「機能」を追加したいときには・・
あるクラスSomethingがあったとする。Somethingに新しい機能を追加したいと思ったとき、
自分らはSomethingのサブクラス（子クラス、派生クラス、拡張クラス）として、SomethingGoodクラスを作る。
このとき小さなクラス階層ができる。
	Something
	 ↪︎SomehitngGood
これは機能を追加するために作られた階層になる。
・スーパークラスは基本的な機能を持っている。
・サブクラスで新しい機能を追加する。
このクラス階層を「機能のクラス階層」と呼ぶことにしている。
さて、SomethingGoodクラスに、さらに新しい機能を追加するとする。
その場合にSomethingGoodクラスのサブクラスとして、SomethingBetterクラスを作流。
これで、さらに機能のクラス階層が深くなる。
	Something
	 ↪︎SomehitngGood
	  ↪︎SomehitngBetter
新しい機能を追加したいと思ったときに、クラス階層の中から自分の目的に近いクラスを探し出し、
そのサブクラスを作り、目的の機能を追加した新しいクラスを作る・・・。
これが機能のクラス階層
※一般的に、クラス階層はあまり深くしすぎない方が良いと言われている。

・新しい「実装」を追加したいときには・・・
Template Methodパターンなどで、抽象クラスの役割について学んだ。
抽象クラスが一連のメソッド群を抽象メソッドとして宣言し、インタフェースを規定する。
そしてサブクラスの側で、その抽象メソッドを実際に実装する。
スーパークラスは抽象メソッドでインタフェースを規定するという役割を持つ。
サブクラスはそれを実装するという役割を持つ。
このようなスーパークラスとサブクラスの役割分担によって、部品としての価値（交換可能性）の高いクラスを作ることができる。
ここにもクラス階層が登場する。例えば、スーパークラスAbstractClassの抽象メソッドを実装したサブクラスをConcreateClassとすると、
次のような小さなクラス階層が作られる。
	AbstractClass
	 ↪ConcreateClass
でも、ここで使われているクラス階層は、機能を追加するために使われているわけではない。
新しいメソッドを増やすためにクラス階層を作っているのではない。
ここでは、次のような役割分担のためにクラス階層が使われている。
・スーパークラスは抽象メソッドによってインタフェースを規定している
・サブクラスは具象メソッドによってそのインタフェースを実装する
このクラス階層を、「実装のクラス階層」と呼ぶことにしている。
さて、AbstractClassの別の実装を作ろうとすると、その時のサブクラスを
AnotherConcreateClassとすると、実装のクラス階層はまた少し変化する。
	AbstractClass
	 ↪ConcreateClass
	  ↪AnotherConcreateClass

クラス階層の混在とクラス階層の分離
自分達が「サブクラスを作ろう！」と思った時、
自分の意図を次のように確認する必要がある。「私は、機能を追加しようとしているのか？　それとも
実装を行おうとしているのか？」クラス階層が1つだと、機能のクラス改装と実装のクラス階層とが1つの階層構造の中に混在することになる。
これは、クラス階層を複雑にし、見通しを悪くしてしまう恐れがある、
自分がサブクラスを作るときに、クラス階層のどこに作ったらいいか迷ってしまうことになるから。
そこで「機能のクラス階層」と「実装のクラス階層」を2津の独立したクラス階層に分けてしまおう。
単に分けただけではバラバラになってしまうので、その2つのクラス階層の間に橋渡しをすることが必要になる。
この橋渡しをするパターンが
Bridgeパターン！！

サンプルプログラムは
「何かを表示する」ためのもの。
抽象的だが、プログラムを読むと具体的になっていく

Bridgeパターンの登場人物
・Abstraction（抽象化）の役
「機能のクラス階層」の最上位のクラス
Implementor役のメソッドを使って基本的な機能だけが記述されているクラス
このインスタンスは、Implementor役を保持する。
サンプルプログラムでは、Displayクラスがこの役を務める。

・RefinedAbstraction（改善した抽象化）の役
Abstraction役に対して機能を追加した役
サンプルプログラムでは、CountDisplayクラスがこの役を務める。
︎︎
・Implementor（実装者）の役
「実装のクラス階層」の最上位のクラス
Abstraction役のインタフェースを実装するためのメソッドを規定する役
サンプルプログラムでは、DisplayImplクラスがこの役を務める。

・ConcreateImplementor（具体的な実装者）の役
具体的にImplementor役のインタフェースを実装する役
サンプルプログラムでは、StringDisplayImplクラスがこの役を務める。


Bridgeパターンの特徴は、「機能のクラス階層」と「実装のクラス階層」を分けている点にある。
この2つのクラス階層を分けておけば、それぞれのクラス階層を独立に拡張することができる。
機能を追加したければ、機能のクラス階層にクラスを追加する。
このとき、実装のクラス階層は全く修正する必要がない。
しかも、いま追加した機能は「全ての実装」で利用できることになる。
例えば、実装のクラス階層をOSに当てはめて考えると、
あるプログラムにOS依存の部分があり、Windows版、Macintosh版、UNIX版に分かれるとする。
そのOS依存の部分をBridgeパターンの「実装のクラス階層」で表現する。
つまり、各OS共通のインタフェースを決めてImplementor役とし、ConcreateImplementor役として
Windows版、Macintosh版、UNIX版の3つのクラスを作る。
こうしておけば、「機能のクラス階層」側でいくら機能を追加しても、3つのOSに同時に対応していることになる。

「継承」はクラスを拡張するために便利な方法ですが、クラス間の結びつきをがっちり固定している。
class SomethingGood extends Something{}
と書いたら、SomethingGoodクラスはSomethingクラスのサブクラスになる。
そしてこの関係は、ソースコードを書き換えない限り変えることはできない。
ソースコードを書き換えない限り変えられないというのは非常に硬い結びつき。

プログラムの必要に応じてカチカチとクラス間の関係を切り替えたちときには、継承を使うのは不適切。
切り替えるたびにソースコードを変更するなんて、やっていられない。
このような時は「継承」ではなく「委譲」を使う。
サンプルプログラムでは、Displayクラスの中で委譲が使われている。
Displayクラスのimplフィールドには、実装のインスタンスが保持されており、
・openを実行するときにはimpl.rawOpen()を呼び出す
・printを実行するときにはimpl.rawPrint()を呼び出す
・closeを実行するときにはimpl.rawClose()を呼び出す
というふうに「たらい回し」している。
「仕事をやれ」と言われたら、「impl君にお任せ」している。これが「委譲」。
継承は固い結びつきだが委譲は緩やかな結びつき。
Displayクラスのインスタンスを作る段階で、引数に渡されてきたものと結びつくのですから。
サンプルプログラムでは、Mainクラスの中でDisplayやCountDisplayのインスタンスを作り、そのときにStringDisplayImplのインスタンスを引数に渡した。
もしも、StringDisplayImplクラス以外のConcreateImplementor役があったとして、そのインスタンスをDisplayやCountDisplayに渡したなら、
それで実装がカチリと切り替わったことになる。
この切り替えを行うのに修正したのはMainクラスだけ。
DiplayやDisplayImplなどのソースコードは、全くいじる必要がない。

練習問題
サンプルプログラムにクラスを追加して、「ランダム回数表示する」という処理を実現してください
表示メソッドは void randomDisplay(int times)とし、0以上times未満だけランダムに表示するようにする。
