Stateパターン

【状態をクラスとして表現する】

オブジェクト指向プログラミングは、プログラムする対象を「クラス」として表現する。
どのようなものをクラスとして表現するかは、設計をする人が考えることになる。
クラスに対応する具体的な「もの」が実世界に存在する場合もあるし、存在しない場合もある。
ときには、「こんなものがクラスになるのか？」と驚くようなものをクラスにする場合もある。
この  Strategyパターンでは、
「状態」というものをクラスとして表現する。
stateとは「状態（ものごとのありさま）」を意味する。
現実世界で私たちは、いろんなものの「状態」について考える。
しかし、状態を「もの」として考えることは滅多にない。
なので「状態をクラスで表現する」というのは、なかなか理解しにくいかもしれない。
状態をクラスとして表現していれば、クラスを切り替えることによって「状態の変化」が表せる。
新しい状態を追加しなければならないときに何をプログラムすればよいかがはっきりとする。

サンプルプログラムでは、
「金庫警備システム」を作成している。
時刻ごとに警備の状態が変化する金庫警備システムを考えてみる。
・金庫が1つある
・金庫は警備センターへと接続されている
・金庫には非常ベルと通常通話用の電話が接続されている
・金庫には時計がついていて、現在の時刻を監視している
・昼間は9:00~16:59、夜間は17:00~23:59および0:00~8:59の範囲である
・金庫は昼間だけ使用できる
・昼間、金庫を使用すると、警備センターに使用記録が残る
・夜間、金庫を使用すると、警備センターに非常事態の通報がいく
・非常ベルはいつでも使用できる
・非常ベルを使用すると、警備センターに非常ベルの通報がいく
・通常通話用の電話はいつでも使用できる（が、夜間は録音のみ）
・昼間、電話を使用すると、警備センターが呼び出される
・夜間、電話を使用すると、警備センターの留守録が呼び出される
という内容のシステム。
プログラム上の1秒を実世界の1時間と仮定している。

Stateパターンを使用しない場合

警備システムのクラス {
	金庫使用時に呼ばれるメソッド() {
		if (昼間) {
			警備センターに利用の記録
		} else if (夜間) {
			警備線tなーに非常事態の通報
		}
	}

	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}

	通常通話時に呼ばれるメソッド() {
		if (昼間) {
			警備センターの呼び出し
		} else if (夜間) {
			警備センターの留守録の呼び出し
		}
	}
}

Stateパターンを使った場合

昼間という状態を表現するクラス {
	金庫使用時に呼ばれるメソッド() {
		警備センターに利用に記録
	}

	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}

	通常通話時に呼ばれるメソッド() {
		警備センターの呼び出し
	}
}

夜間という状態を表現するクラス {
	金庫使用時に呼ばれるメソッド() {
		警備センターに非常事態の通報
	}

	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}

	通常通話時に呼ばれるメソッド() {
		警備センターの留守録の呼び出し
	}
}

この２つのパターンの違い
Stateパターンを使用しない場合は、昼間・夜間という状態を各メソッドの中のif文のところに登場する
そして、各メソッドの中で現在の状態を調べている。
Stateパターンを使用する場合は、昼間・夜間という状態クラスとして表現されている。
状態がクラスとして表現されているので、その中のメソッドには、もはや状態チェックのためのif文は登場しない。
使用する場合は、「状態」がメソッドの中に書かれているが、
使用しない場合は、「状態」をクラスとして書かれている。

Stateパターンの登場人物
・State（状態）の役
State役は、状態を表すためのもの。
状態ごとに異なる振る舞いをするインタフェースを定める。
このインタフェースは、状態に依存した振る舞いをするメソッドの集まりになる。
サンプルプログラムでは、Stateインタフェースがこの役を務める

・ConcreateState（具体的な状態）の役
ConcreateState役は、具体的な個々の状態を表現するもの。
State役で定められたインタフェースを具体的に実装する。
サンプルプログラムでは、DayStateクラス、NightStateクラスがこの役を務める。

・Context（状況、前後関係、文脈）の役
Context役は、現在の状態を表すConcreateState役を持つ。
また、Stateパターンの利用者に必要なインタフェースを定める。
サンプルプログラムでは、ContextインタフェースとSafeFrameクラスがこの役を務める。
サンプルプログラムでは、Contextインタフェースがインタフェースを定める部分を担い、
SafeFrameクラスがConcreteState役を持つ部分を担っている。

分割して統治せよ
分割して統治せよという方針は、プログラミングによく登場する。
これは、複雑で大規模なものを取り扱う場合の方針で、大きくてややこしい問題は、そのまま解こうとしてはいけない。
その問題をまず小さな問題に分ける。
それでもまだ解きにくかったら、さらに小さな問題に分ける。
問題は、簡単に解けるまで小さくしてから解く。大きくてややこしい問題を1つ解く代わりに、
小さくて優しい問題をたくさん解きなさい。・・・が分割して統治せよ、ということ

Stateパターンでは、「状態」をクラスで表現している。個々の具体的な状態を、別々のクラスとして表現して
問題を分割したのだ。
1つのConcreateState役のクラスをコーディングしている最中、プログラマは、他のクラスのことを（ある程度）頭から追い出すことができる。
サンプルプログラムのように2つしか状態が出ない場合はありがたみを感じにくいが、状態が多いときにはStateパターンのありがたみがわかる。

状態に依存した処理
SafeFrameクラスのsetClockメソッドは、Mainクラスから「時刻の設定をしてね」と呼ばれている。
setClockの中では、その処理を
 state.doClock(this, hour);
として、stateに委譲している。つまり、時刻の設定を「現在の状態に依存した処理」として扱っている。
doClockメソッドだけに限らず、Stateインタフェースで宣言されているメソッドというのは、
全て「状態に依存した処理」であり、「状態によって振る舞いが異なる処理」だ。
Stateパターンでは、「状態に依存した処理」というものをプログラムで以下のように表現している
・抽象メソッドとして宣言し、インタフェースとする
・具象メソッドとして実装し、個々のクラスとする

状態遷移は誰が管理すべきか
Stateパターンを使う場合、状態遷移は誰が管理すべきかという点には注意しないといけない。
サンプルプログラムでは、Context役のSafeFrameクラスが、状態遷移を実際に行うchangeStateメソッドを実装した。
しかし、changeStateメソッドを実際に呼び出しているのは、ConcreateState役のDayStateやNightStateクラスだ。
すなわち、サンプルプログラムでは、「状態遷移」を「状態に依存した振る舞い」であるとみなしている。
このやり方の良い点
「他の状態に遷移するのはいつか」という情報が、1つのクラス内にまとまっている点
すなわち、「DayStateクラスが他の状態に遷移するのはいつかな？」と知りたいときには、DayStateクラスのコードを読めばいい
悪い点
「1つのConcreateState役が、他のConcreateState役を知らなければならない」という点。
例えば、DayStateクラスはdoClockメソッドの中でNightStateクラスを使っている。これは将来、NightStateクラスを削除したくなったときには、
DayStateクラスも修正をしないといけない。
状態遷移をConcreateState役に任せるということは、そのConcreateState役が、少なくとも他のConcreateState役を知らなければならない。
つまり依存関係を深めてしまっている。
全ての状態遷移をContext役のSafeFrameクラスに任せることもできる。そうすれば、個々のConcreateState役の独立性が高まり、
プログラム全体の見通しが良くなる場合がある。しかし今度は、Context役が「全てのConcreateState役」を知らないといけなくなる。
ここにMediatorパターンを適用できるかもしれない。
あるいはまた、Stateパターンの代わりに状態のテーブルを使って設計する手もある。

自己矛盾が起こらない
Stateパターンを使用しないで、システムの状態が複数の変数の値の集合で表現されているとする。
そのとき、変数の値の間に自己矛盾や不整合があってはいけない。
Stateパターンでは、状態をクラスで表現する。現在の状態を表す変数は、たっと1つ。
サンプルプログラムでは、SafeFrameクラスのstateフィールドで、システムの状態をズバリ決定している。
このため、自己矛盾を孕んだ状態というのが存在しないことになる。

新し状態を追加するのは簡単
しかし、出来上がっているStateパターンに新しい、「状態依存の処理」を追加するのは困難。
それは、State役のインタフェースにメソッドを追加することを意味し、全てのConcreateState役に処理を追加することになるから。

複数の顔を持つインスタンス
SafeFrameクラスに登場した以下の2つの文
・SafeFrameのコンストラクタ
　buttonUse.addActionListener(this);
・actionPerformedのメソッド
　state.doUse(this);
この2つの文は、thisが登場しているがこれは何か。
もちろんどちらもSafeFrameクラスのインスタンスだが、サンプルプログラムでは、
SafeFrameノインスタンは1つしか作ってないのでどちらも同じ値になっている。
だけど、addActionListenerとdoUseに渡される時では少し扱いが異なる。
addActionListenerに渡されるときは、
このインスタンスは「ActionListenerインタフェースを実装しているクラスのインスタンス」として扱われる。
doUseに渡されるときは、
同じインスタンスが、「Contextインタフェースを実装しているクラスのインスタンス」として扱われる。