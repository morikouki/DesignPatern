Decoratorパターン

【飾り枠と中身の同一視】

スポンジケーキが一つあったとする。
クリームを塗れば、何も乗っていないショートケーキが出来上がる。
そこにイチゴを並べれば、ストロベリーショートケーキになる。
さらに板チョコを載せて、ホワイトチョコレートで名前を書き、年齢の数だけキャンドルを立てれば、バースデーケーキが出来上がる。
スポンジケーキもショートケーキも、ストロベリーケーキも、バースデーケーキも中心にあるのは同じスポンジケーキ。
でも、クリームを塗り、ストロベリーを載せ、、、と、いろいろデコレーションをしていくうちに、より美味しく、それぞれの目的に合ったケーキになる。
オブジェクトも、このようなケーキと似ていることがある。
まず、中心となるスポンジケーキのようなオブジェクトがある。
それに飾り付けとなる機能を一皮一皮被せていって、より目的に合ったオブジェクトに仕上げていく。
このような、オブジェクトにどんどんデコレーション（飾り付け）を施していくようなデザインパターンを
Decoratorパターン
呼ぶ、decoratorとは、「decorate（飾り付け）するもの」という意味。

サンプルプログラムでは、
文字列の周りに飾り付けて表示するというもの。
ここでいう飾り枠とは、 -, +という文字で描いたもののこと。

Decoratorパターンの登場人物
・Componentの役
機能を追加するときの核になる役
ケーキで言えば、デコレーションする前のスポンジケーキにあたる。
Component役はスポンジケーキのインタフェースだけを定めている。
サンプルプログラムでは、Displayクラスがこの役を務める

・ConcreateComponentの役
Component役のインタフェースを実装している具体的なスポンジケーキ
サンプルプログラムでは、StringDisplayクラスがこの役を務める

・Decorator（装飾者）の役
Component役と同じインタフェースを持つ、
そしてさらに、このDecorator役が飾る対象となるComponent役を持っている。
この役は、自分が飾っている対象を「知っている」わけ。
サンプルプログラムでは、Borderクラスがこの役を務める

・ConcreateDecorator（具体的な装飾者）の役
具体的なDecoratorの役
サンプルプログラムでは、SideBorderクラスとFullBorderクラスがこの役を務める。

透過的なインタフェース
Decoratorパターンでは、飾り枠と中身を同一視している。
具体的に言えば、サンプルプログラムでは、飾り枠を表すBorderクラスが、中身を表すDisplayクラスのサブクラスになっているところで、
その同一視が表現されている。つまり、Borderクラス（およびそのサブクラス）は中身を表すDisplayクラスと同じインタフェースを持っている。
飾り枠を使って中身を包んでも、インタフェースは少しも隠されません。
getColumns, getRows, getRowText, それにshowというメソッドは隠されることなく他のクラスから見ることができる。
これは、インタフェースをが「透過的」であるという。
サンプルプログラムのインスタンスb4のように、飾り枠をたくさん使って包んでも、インタフェースは全く変更されない。
インタフェースが透過的であるため、Decoratorパターンでは、Compositeパターンに似た再帰的な構造が登場する。
すなわち、飾り枠が保持している「中身」が、実際に別のものの「飾り枠」になっているという構造です。
タマネギの皮を剥いて中身が出てきたと思ったら、それもまた皮だったというようなもの。
DecoratorパターンとCompositeパターンは、再帰的な構造を扱うという点では似ているが、
目的は異なります。Decoratorパターンとは外枠を重ねることで機能を追加していく点に主眼があるから。

中身を変えずに、機能追加できる
Decoratorパターンでは、飾り枠も中身も共通のインタフェースを持っている。
インタフェースは共通ですが、包めば包むほど機能が追加されていくが、DisplayをSideBorderで包めば、
左右に新しい飾り文字をつける表示ができるようになる。
さらにFullBorderで包めば、今度は周り全体に飾り枠がつきます。
その際に包まれる方を修正する必要はありません。
包まれるものを変更することなく、機能の追加を行うことができる。
Decoratorパターンでは委譲が使われる、「飾り枠」に対してやってきた要求（メソッドの呼び出し）は、
その「中身」にたらい回し（委譲）されます。サンプルプログラムでは、SideBorderのgetColumnsメソッドの中で
display.getColumns()を呼び出している。
また、getRowsメソッドでは、display.getRows()を呼び出している。

動的な機能追加できる
Decoratorパターンで使われている委譲は、クラス間を緩やかに結合している。
なので、フレームワークのソースを変更することなく、オブジェクトの関係を変えた新しいオブジェクトを作ることができる。

単純な品揃えでも、多様な機能追加ができる
Decoratorパターンを使うと、多様な機能追加を行うことができる。
具体的な飾り枠（ConceateDecorator役）をたくさん用意しておけば、それらを自由に組み合わせても新しいオブジェクトを作ることができる
その際に、個々の飾り枠は単純でもかまわない。
これは、バニラ、チョコ、ストロベリー、キーウィ、・・といったフレーバーを自由に選べるアイスクリームのようなもの。
お客さんが注文するかもしれないさまざまなアイスクリームを、はじめから全部用意していたら大変です。
お店では多種類のフレーバーだけを用意する。
そして、お客さんに注文に合わせてフレーバーを組み合わせ、注文どおりのアイスクリームを作る。
バニラだけが食べたい、コーヒーラムとピスタチオのダブルが食べた、バニラとストロベリーとキーウィのトリプルが食べたい・・・と、
お客さんの注文はさまざま、Decoratorパターンは、そのような多様な要求に応えるのに向いている。

Decoratorパターンを使うと、よく似ている小さなクラスがたくさん作られるてしまうという欠点もある。

