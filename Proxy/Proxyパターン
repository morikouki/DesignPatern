Proxyパターン

【必要になってから作る】

proxyというのは「代理人」という意味で、仕事を行うべき本人の代わりとなる人。
本人でなくてもできるような仕事を任せるために代理人を立てる。代理人はあくまで代理に過ぎないので、できることには限界がある。
代理人にできる範囲を超えた仕事がやってきたら、代理人は本人のところにやってきて、相談をする必要がある。
オブジェクト指向では「本人」も「代理人」もオブジェクトとなる。
忙しくてその仕事ができない本人オブジェクトの代わりに、代理人オブジェクトが（ある程度）仕事をこなしてやることになる。

サンプルプログラムでは
「名前付きのプリンタ」を作成している。
プリンタと言っても実際には画面に文字列を表示するだけ
Mainクラスは、PrinterProxyクラスのインスタンス（代理人）を生成し、そのインスタンスには「Alice」という名前をつけ、
その名前を表示する。その後「Bob」という名前に変更して、その名前を表示する。
名前の設定や取得では、まだ本物のPrinterクラスのインスタンス（本人）を生成していない。
名前の設定と取得という部分はPrinterProxyクラスが代理で行う。
最後にprintメソッドを呼び出して、実際にプリントを行う段階になって初めて、PrintProxyクラスは、
Printerクラスのインスタンスを生成する。
PrinterProxyとPrinterを同一視するために、Pritableというインタフェースが定義されている。
Printerクラスのインスタンス生成にとても時間がかかるという前提で、プログラムを作成している。
時間がかかるということを表現するために、コンストラクタからheavyJobというメソッドを呼び出し、
わざと「重い仕事」をさせている。（5秒ほど時間稼ぎをさせている）

Proxyパターンの登場人物
・Subject（主体）の役
Proxy役とReaSubject役を同一視するためのインタフェースを定める
Subject役があるおかげで、Client役は、Proxy役とRealSubject役の違いを意識する必要がない。
サンプルプログラムでは、Printableインタフェースがこの役を務める。

・Proxy（代理人）の役
Proxy役はClient役からの要求をできるだけ処理する。
もしも、自分だけで処理できなかったら、Proxy役はRealSubject役に仕事をお任せする。
Proxy役は、本当にRealSubject役が必要になってからRealSubject役を生成する。
Proxy役はSubject薬で定められているインタフェースを実装する。
サンプルプログラムでは、PrinterProxyクラスがこの役を務める。

・RealSubject（実際の主体）の役
「代理人」のProxy役では手に負えなくなったときに登場するのが、「本人」のRealSubject役
この役も、Proxy役と同じくSubject薬で定められているインタフェースを実装している。
サンプルプログラムでは、Printerクラスがこの役を務める。

・Client（依頼人）の役
Proxyパターンを利用する役。
サンプルプログラムでは、Mainクラスがこの役を務める。

代理人を使ってスピードアップ
Proxyパターンでは、Proxy役が代理人となって、できるだけ処理を肩代わりする。
例えば、サンプルプログラムでは、Proxy役を使うことによって、実際にprintするときまで、重い処理（インスタンス生成）を遅らせることでできている。
サンプルプログラムでの重い処理は高が知れているが、例えば、初期化に時間がかかる機能がたくさん存在するような大きなシステムでは、
起動の時点では利用しない機能まで全部初期化してしまったら、アプリケーションの起動に時間がかかってしまうことになる。
これではユーザが不満を感じてしまう。実際にその機能を使う段階になって初めて初期化したほうが、ユーザに与えるストレスが少なくなる。

代理人と本人を分ける必要はあるのか
PrinterProxyとPrinterクラスを分けずに、Printerクラスの中に最初から遅延評価の機能（必要になってから初めてインスタンスを生成する機能）
を入れておくこともできる。しかし、Proxy役とRealSubject役を分けることで、プログラムの部品かが進み、個別に修正を加えることができる（分割して統治せよ!）
PrinterProxyクラスを実装を変えれば、Printableインタフェースで宣言されているメソッドのうち、何を代理人が処理し、
何を本人が処理するのかを変更することができる。しかもそのような変更をいくら加えても、Printerクラスの方を修正する必要は全くないのだ。
もしも、地縁評価を全く行わないようにしたいなら、MainクラスでPrinterProxyクラスのインスタンスをnewするのではなく、Printerクラスのインスタンスを
newすれば良い。

代理と委譲
代理人だけで処理できる仕事は代理人が処理する。
代理人が処理できないときには処理できる本人に「お任せ」する。これは以上をしている。

透過的
PrinterProxyクラスとPrinterクラスは、同じPrintableというインタフェースを実装している。
Mainクラスは、実際に呼び出すのがPrinterProxyクラスでもPrinterクラスでも、気にしない。
Pritnerを直接利用しても、間にPrinterProxyが入っても、問題なく利用できる。
このようなとき、PrinterProxyクラスは「透過的」であるといえる。
自分と絵の間に透明なガラス板が置かれても、絵が透けて見えるように、MainクラスとPrinterクラスの間に
PrinterProxyクラスが置かれても、問題は起きない。

HTTPプロキシー
プロキシーというと、HTTPプロキシーを思い浮かべるかもしれない。
HTTPプロキシーは、HTTPサーバとHTTPクライアントの間に入って、Webページのキャッシングなどを行うソフトウェアで、
これもProxyパターンに当てはめて考えることができる。
WebブラウザであるWebページを表示するとき、いちいち遠隔地にあるWebサーバにアクセスして、そのページを取得するのではなく、
HTTPプロキシーがキャッシュしてあるページを代わりに取得する。最新情報が必要になった時やページの有効期限が切れたときに初めて
WebサーバにWebページを取りに行くのだ。
WebブラウザがClient役、HTTPプロキシーがProxy役、WebサーバがRealSubject役を務めている。

Proxyのバリエーション
・Virtual Proxy（仮想プロキシー）
Proxyパターンと同じ、本当にインスタンスが必要になった時点で、生成・初期化を行う

・Remote Proxy（遠隔プロキシー）
RealSubject役がネットワークの向こう側にいるにも関わらず、
あたかも自分のそばにいるかのように（遠隔的に）、メソッド呼び出しができるもの。
JavaのRMI(Remote Method Invocation：遠隔メソッド呼び出し)などがこれに相当する。

・Access Proxy
RealSubject役の機能に対して、アクセス制限を設けるもの
定められたユーザならメソッド呼び出しを許可するが、それ以外はエラーになるような処理を行うプロキシー
