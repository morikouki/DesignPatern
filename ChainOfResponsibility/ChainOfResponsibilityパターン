Chain of Responsibilityパターン

【責任のたらい回し】

たらい回しについて考える。
ある書類をもらいに会社に行ったとする。
会社の受付に言ったところ「営業窓口」に行って欲しいと言われた。
そこで営業窓口に行くとその書類は、「ユーザサポート部」で扱っていると言われた。
そこでユーザサポート部に行くと、「文書センター」で入手できると言われた。
。。。。とこんなふうに自分の要求が次へ次へと送られる、、これがたらい回し。

たまに「たらい回し」と表現したくなる処理が必要になる場合がある。
ある要求が発生した時に、その要求を処理するオブジェクトをダイレクトに決められない場合だ。
そのような時、複数のオブジェクトを鎖（チェーン）のように繋いでおき、そのオブジェクトの鎖を順次渡り歩いて、
目的のオブジェクトを決定する方法が考えられる。
このようなパターンを
  Chain of Responsibilityパターン
 と呼ぶ。

 responsibilityは「責任」ということで日本語で「責任の連鎖」という。
 要するに「たらい回し」。
 このパターンを使うと、「要求する側」と「処理する側」の結びつきを弱めることができ、
 それぞれを部品として独立させることができる。また、
 状況によって要求を処理するオブジェクトが変化するようなプログラムにも対応することができる。
 人に要求がやってくる。その人がそれを処理できるなら処理する。
 できないならその要求を次の人へたらい回しする。
それが繰り返されていく。
それがこのパターン

サンプルプログラムでは、
発生したトラブルを誰かが処理しなければならない状況を考えている。

Chain of Responsibilityパターンの登場人物
・Handler（処理者）の役
Handler役は、要求を処理するインタフェースを定める役です。
「次の人」を保持しておき、自分が処理ができない要求がきたら、その人にたらい回しします。
もちろん、「次の人」もHandler役。サンプルプログラムでは、Supportクラスがこの役を務める。

・ConcreateHandler（具体的処理者）の役
ConcreateHandler役は、要求を処理する具体的な役です。
サンプルプログラムでは、NoSupport, LimitSupport, OddSupport, SpecialSupportの各クラスが、この役を務める

・Client（要求者）の役
Client役は、最初のConcreateHadler役に要求を出す役です。
サンプルプログラムでは、Mainクラスがこの役を務める。

要求を出す人と要求を処理する人を緩やかに結びつける
Chain of Responsibilityパターンのポイントは、要求を出す人（Client役）と要求を処理する人（ConcreateHandler役）
をゆるやかに結びつけるところにある。
Client役は、最初の人に要求をポンと出してしまう。すると、あとは連鎖の中をその要求が流れていき、適切な処理者によって要求が処理されることになる。
もしもこのパターンを使わないと、「この要求はこの人が処理すべし」という知識を誰をかが中央集権的に持っている必要がある。
その知識を「要求を出す人」に持たせるのはあまり賢明ではない。
要求を出す人が処理者たちの役割分担の詳細までは知らなければならないとすると、部品としての独立性が損なわれてしまうから。

動的に連鎖の形態を変える
サンプルプログラムでは、AliceからFredまでのサポートチームはいつも固定した順序になってた。
しかし、要求を処理するConcreateHandler役のオブジェクトの関係が動的に変化するような状況も考えられる。
Chain of Responsibilityパターンのように委譲によってたらい回しを行なっていれば、状況の変化に応じて
ConcreateHandler役を組み替えることができる。
もしも、Chain of Responsibilityパターンを使わず、プログラムの中に「この要求ならこの処理者」という
対応関係が固定的に書かれていたら、プログラムが動いている最中に処理者を変更することは難しくなる。

ウィンドウシステムでは、ユーザがウィンドウ上にコンポーネント（ボタンやテキスト入力フィールド）を
自由に追加できる場合がある。このような時にはChain of Responsibilityパターンが有効に働く。

自分の仕事に集中できる
「たらい回し」というのは否定的なニュアンスが強いですが、言い換えれば、各オブジェクトが
「自分の仕事に集中できる」ということでもある。個々のConcrateHandler役は、自分のできる仕事に集中。
自分ができなかったら、あっさりと「次の人、お願いね」と渡してしまう。
そうすれば、個々のConcreateHandler役で書くべき処理は、そのConcreateHandler役に固有の内容に絞り込める。
Chain of Responsibilityパターンを使わないとすると、この場合には、「偉い人が1人いて、誰が要求を処理するかを全て決定する」
という方法を取ることになる。
あるいは、「自分が処理できなかったら、あの人に任せる。もしもそれでも駄目ならこの人、システムの状況がこうならあっちの人」という
「仕事の振り分け」の仕事まで個々のConcreateHandler役に背負わせる方法をとることになる。

たらい回し処理は遅くならないのか
 Chain of Responsibilityパターンの使ってたらい回しを行い、
 適切な処理を行う相手を探すというのは、確かに柔軟性は高いかもしれませんが、
 処理が遅くなってしまうのではないか。
 その通り、誰が要求を処理をすべきかが前もって定まっており、その相手がすぐに処理をする場合と比較すると、
 Chain of Responsibilityパターンを適用した場合の処理は遅くなる。
 しかし、これはトレードオフの問題です。要求と処理者の関係が固定的で、しかも処理速度が非常に重要な場合には、
 Chain of Responsibilityパターンのを使わないほうが有効な場合もある。

