Mediatorパターン

【相手は相談役1人だけ】

揉めているグループを想像してほしい。
同じ立場のメンバーが10人集まって、共同作業をしているが、なかなかまとまりがつかない。
メンバーが互いに指示を出し合って、作業は大混乱する。
また、互いの作業の詳細に首を突っ込んで、揉め事が起こっている。
そんなところに、立場の異なる「相談役」が登場して、こう言った。
「メンバーの皆さんは、相談役の私に状況を報告してください。そうしたら、私は全体を考慮した上で皆さんに指示を出しましょう。でも私は、
皆さんの仕事の詳細まではとやかく言いませんからね。」全てのメンバーがこの相談役のいうことを了承して話はまとまった。
メンバーはみんな相談役だけに報告し、メンバーへの指示は相談役だけからくるようになった。
そして、メンバー同士の揉め事も無くなった。
mediatorというのは「調停者」「仲介者」という意味で、先の相談役のようなもの。
Mediatorパターンは以下のようなデザインパターン
「相談役」はmediator（調停者）、「各メンバー」はcolleague（同僚）と呼ばれる。

サンプルプログラムは、
「名前とパスワードを入力するログインダイアログ」というGUIアプリケーション。
以下のように使う
・ゲストログイン（Guest）か、ユーザログイン（Login）かを選択する
・ユーザログインの場合には、ユーザ名（Username）とパスワード（Password）を入力する
・ログインするなら「OK」ボタン、やめるなら「Cancel」ボタンを押す
（サンプルプログラムは、どこにもログインしない。ボタンを押したら単に終了するだけ）

上記の機能だけなら単純だが、、、、以下の機能を追加すると大変になる
・ゲストログインが選ばれているときには、ユーザ名とパスワードを「無効状態」にして、文字列が入力できないようにする
・ユーザログインが選ばれているときには、ユーザ名は「有効状態」になり、文字列が入力できるようになる
・ユーザ名に文字が1文字も入っていない場合には、パスワードは「無効状態」になる
・ユーザ名に文字が1文字でも入っていたら、パスワードは「有効状態」になる。
（ゲストログインの場合には「無効状態」）
・ユーザ名とパスワードの両方に文字が1文字でも入っている場合には、OKボタンは「有効状態」になり、押せる状態になるが、
ユーザ名とパスワードのどちらか一方でも空ならば、OKボタンは「無効状態」になって、押せない状態になる。
（ゲストログインの場合には、OKボタンは常に「有効状態」）
・Cancelボタンは常に「有効状態」で、いつでも押せる状態になっている。

ダイアログ上のラジオボタンや、テキストフィールド、それにボタンなんかは、それぞれ別のクラスになっている。
もしも、上記のロジックを各クラスに分散させると、コーディングは非常に大変になる。
なぜならば、それぞれのオブジェクトが互いに関係しあっているため、お互いがお互いをコントロールするような状況に陥ってしまう。
「ユーザログインが選ばれたとき、ユーザ名を有効にして、パスワードも有効にするんだけれど、もしもユーザ名が空だったらパスワードは有効にしない。
そして、ユーザー名とパスワードの両方に文字列が入っていたら、OKボタンを有効にする」というコードはどこに書くのか。。
ラジオボタンのところ？でもそんなことをしていたら、表示のコントロールのための似て日なるコードが各クラスにバラバラに書かれることになる。
それでは、プログラムを書くのも、デバッグするのも大変。しかも、もし仕様変更が行われて
「メールアドレスを入力する欄を追加」することになったりしたら・・・ぞっとする。
上記のような、多数のオブジェクトの間の調整を行わなければならないときこそ、Mediatorパターンの出番だ。
個々のオブジェクトが互いに通信し合うのではなく、「頼りになる相談役」を置き、その相談役とだけ通信することにする。
そして、表示のコントロールのロジックは、相談役の中にだけ記述する。

Mediatorパターンの登場人物
・Mediator（調停者、仲介者）の役
Mediator役は、Colleague役と通信を行なって、調整を行うためのインタフェースを定める。
サンプルプログラムでは、Mediatorインタフェースがこの役を務める。

・ConcreateMediator（具体的な調停者、仲介者）の役
ConcreateMediator役は、Mediator役のインタフェースを実装し、実際の調整を行う
サンプルプログラムでは、LoginFrameクラスがこの役を務める。

・Colleague（同僚）の役
Colleague役は、Mediator役と通信を行うインタフェースを定める
サンプルプログラムでは、Colleagueインタフェースがこの役を務める。

・ConcreateCollague（具体的な同僚）の役
ConcreateColleague役は、Colleague役のインタフェースを実装する
サンプルプログラムでは、ColleagueButton, ColleagueTextField, ColleagueCheckboxがこの役を務める。

分散が災いになるとき
サンプルプログラムのLoginFrameに書かれているcolleagueChangedメソッドは、少々複雑で、
仕様変更があったら、この複雑なメソッドの中に結局バグが入り込むのではないか。
そうかもしれないが、それは問題ない。
例え、バグが入り込んでも、表示の有効・無効に関するロジックは、ここ以外に存在しないので、ここをデバッグすればいいのだ。
もしも、ColleagueButton, ColleagueTextField, ColleagueCheckboxにcolleagueChangedが分散していたら、、、、
書くのも、デバッグするのも、修正するのも大変だ。
オブジェクト指向では、一極集中を避け、処理を分散させることが多い、すなわち、問題を「分割して統治」しようとしている。
しかし、今回のサンプルプログラムのような場合には、処理を各クラスに分散させるのは賢明ではない。
各クラスに分散させるべきことは分散させ、集中させるべきことは集中させないと、せっかくのクラスがかえって災いとなってしまう。

通信経路の増加
AとBのインスタンスがあり、お互いに通信しあう（メソッドを呼び合う）とする。
そのとき、通信経路はA→BとB→Aの２本になる。
インスタンスがAとBとCの3個なら、6本になる。4個になると、一気に12本に増え、5個だと20本、6個だと30本になる。
同じ立場のインスタンスがたくさんん存在するとき、それらをお互いに通信させると、プログラムは複雑になってしまう。
インスタンスの数が少ないうちは、問題は大きくない。
しかし、最初の設計のままどんどんインスタンスを増やしていくと、どこかで破綻をきたすのだ。

再利用できるのは何か
ConcreateColleague役は再利用しやすいが、ConcreateMediator役は再利用しにくいと言える。
例えば、ログインダイアログとは別の、新しいダイアログを作るとする。
そのとき、ConcreateColleague役であるColleagueButton, ColleagueTextField, ColleagueCheckboxは、その新しいダイアログでも再利用できる。
なぜなら、ConcreateColleague役の中には、特定のダイアログに依存したコードは含まれていないから。
