Strategyパターン

【アルゴリズムをごっそり切り替える】

strategyというのは「戦略」と意味で、
敵をやっつける時の作戦、軍隊を動かす時の方策、それに問題を解いていく時の方法、そういった意味合いを持っている。
プログラミングの場合には、「アルゴリズム」と考えてもいい。

どんなプログラムも問題を解くために書かれている。
そして問題を解くやめに特定のアルゴリズムが実装されている。
Strategyパターンでは、そのアルゴリズムを実装した部分がゴッソリと交換できるようになっている。
アルゴリズム（戦略・作戦・方策）をカチッと切り替え、同じ問題を別の方法で解くのを容易にするパターンが、
Strategyパターン！

サンプルプログラムでは
コンピュータで「じゃんけん」を行うものを作成
じゃんけんの「戦略」として、2つの方法を考えた。
1つは「勝ったら次も同じ手を出す」という愚かな方法（WinningStrategy）
もう1つは「1回前の手から次の手を確率的に計算する」という方法（ProbStrategy）

Strategyパターンの登場人物
・Strategy（戦略）の役
戦略を利用するためのインタフェースを定める役
サンプルプログラムでは、Strategyインタフェースがこの役を務める

・ConcreateStrategy（具体的戦略）の役
Strategy役のインタフェースを実際に実装する役
ここで具体的な戦略（作戦・方策・方法・アルゴリズム）を実際にプログラミングする。
サンプルプログラムでは、WinningStrategyクラスとProbStrategyクラスがこの役を務める

・Context（文脈）の役
Strategy役を利用する役
ConcreateStrategy役のインスタンスを持っていて、必要に応じてそれを利用する。
（あくまで呼び出すのはStrategy役のインタフェース）
サンプルプログラムでは、Playerクラスがこの役を務める

わざわざStrategy役を作る必要
普通にプログラミングをしていると、メソッドの中に溶け込んだ形で
アルゴリズムを実装してしまいがち。しかし、Strategyパターンでは、アルゴリズムの部分を他の部分と意識的に分離する。
そしてアルゴリズムとのインタフェースの部分だけを規定する。
そして、プログラムから委譲によってアルゴリズムを利用するのだ。
これは、プログラムが複雑になっているように見えるが、そうではない。
例えば、アルゴリズムを改良してもっと高速にしたいとする。
Strategyパターンを使っていれば、Strategy役のインタフェースを変更しないように注意して、ConcreateStrategy役だけをいじればいい。
しかも、委譲というゆるやかな結びつきを使っているので、アルゴリズムを容易に切り替えることができる。
例えば、元のアルゴリズムと改良したアルゴリズムの速度を比較したい場合でも、簡単に切り替えて試すことができる。
Strategyパターンを使っていれば、将棋のゲームを行うプログラムで、ユーザーの選択に合わせて試行ルーチンのレベルを切り替えることも簡単にできる。

Strategyパターンを使えば、プログラムの動作中にConcreateStrategy役を切り替えることもできる。
例えば、メモリが少ない環境ではSlowButLessMemoriyStrategy（スピードは遅いが省メモリの戦略）を使い、
メモリが多い環境ではFastButMoreMemoryStrategy（スピードは速いがメモリを食う戦略）を使うということも考えられる。
片方のアルゴリズムを他方のアルゴリズムの「検算」に使うこともできる。
例えば、表計算ソフトのデバッグ版で、複雑な計算を行うとする。
その時、「バグがあるかもしれない高速なアルゴリズム」と「低速だが確実な計算を行うアルゴリズム」を用意しておき、
前者の検算を後者に行わせるのだ。

練習問題
デタラメに次の手を出すRandomStrategyクラスを作ってください